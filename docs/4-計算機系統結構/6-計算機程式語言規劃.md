## 簡介
在設計一個 CPU 的過程，需要先從 CPU 的需求與功能開始，依序往下規劃指令集與組合語言，才可以設計出一顆 CPU 或一個計算機。

而以計算機結構的方式設計數位電路，是一個在數位系統設計中，有明確方法與基礎可尋，相當完整且可以因應現代對於電腦與運算的需求的方法。

## 指令集
在 Nand2Tetris 中指令集為 16 Bits ，有分成兩種指令集，分別是位址運算元以及指令運算元，區分方式是透過高位元區分兩種資料格式。

- A 指令：定址，設定記憶體位置。
- C 指令：運算元，將 Nand2Tetris 的指令集可以在 CPU 上執行。

### 暫存器存取指令
組合語言格式： `@xxx` \
二進位格式： `0xxxxxxxxxxxxxx`

也就是說 A 指令可以提供 $`16^4 / 2 = 2^{15} = 32768`$ 的定址控制，也就是第二部曲第八章中有出現了 32768x16位元暫存器所組成的記憶體。

那怎麼知道是不是 A 指令？仔細觀察，會有前面多一位元提供識別是否為 A 指令。

### 記憶存取指令
組合語言格式： `dest = comp;jump` \
二進位格式： `111accccccdddjjj`

此指令分成三個部份，運算碼、記憶體位置、跳躍。

### 輸入輸出指令

## 組合語言

```
D;JGT // if D > 0 jump
D;JGE // if D ≥ 0 jump
D;JLT // if D < 0 jump
D;JLE // if D ≤ 0 jump
D;JEQ // if D = 0 jump
D;JNE // if D ≠ 0 jump
0;JMP // jump
```

```
// D ← 2
D=1
D=D+1
```

```
// D ← 1954
@1954 // 透過指令地址的方式給予記憶體數字
D=A
```

```
// D ← D + 23
@23
D=D+A
```

```
// RAM[100] ← 0
@100
M=0
```

```
// RAM[100] ← 17
@17
D=A
@100
M=D
```

```
// RAM[100] ← RAM[200]
@200
D=M
@100
M=D
```

```
// RAM[3] ← RAM[3] – 15
@40 // 透過指令地址的方式給予記憶體數字
D=A
@3
M=D

@15
D=A
@3
M=M-D
```

```
// RAM[3] = RAM[4] + 1
@33 // 透過指令地址的方式給予記憶體數字
D=A
@4
M=D

D=M+1 // RAM[4]本身不加1，RAM[3] + 1
@3
M=D
```

```
// Computes: RAM[2] = RAM[0] + RAM[1] + 17
@22 // 透過指令地址的方式給予記憶體數字
D=A
@0
M=D

@33 // 透過指令地址的方式給予記憶體數字
D=A
@1
M=D

// D = RAM[0]
@0
D=M
```

```
// D = D + RAM[1]
@1
D=D+M

// D = D + 17
@17
D=D+A

// RAM[2] = D
@2
M=D
```

```
// goto 6
@6
0;JMP
```

```
// if (D > 0) goto 6
@6
D;JGT
```

```
// if (D > 0) goto 6
@6
D;JGT
```

```
// if (D = 0) goto 300
@300
D;JEQ
```

```
// if (RAM[3] < 100) goto 12

// D = RAM[3] – 100
@3
D=M
@100
D=D–A

// if (D < 0) goto 12
@12
D;JLT
```

### C語言與組合語言的轉換
```
// i = 1
@i
M=1

// sum = 0
@sum
M=0

// sum = sum + i
@i
D=M
@sum
M=D+M

// i = i + 1
@i
M=M+1
```

轉換使用變數方式：

```
// goto 48
@48
0;JMP

// if (D > 0) goto 21
@21
D;JGT

// if (RAM[100] < 0) goto 35
@100
D=M
@35
D;JLT
```

轉換成變數：

```
// goto LOOP
@LOOP
0;JMP

// if (D > 0) goto CONT
@CONT
D;JGT

// if (x < 0) goto NEG
@x
D=M
@NEG
D;JLT
```
